<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Particle Affinity - Rust WASM + WebGPU</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: black;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(15px);
            padding: 20px;
            border-radius: 12px;
            min-width: 320px;
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 6px;
            color: #ddd;
            font-weight: 500;
            font-size: 13px;
        }

        input[type="number"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #444;
            background: rgba(51, 51, 51, 0.8);
            color: white;
            border-radius: 6px;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
        }

        button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border: none;
            color: white;
            border-radius: 6px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .affinity-matrix {
            margin-top: 10px;
        }

        .matrix-grid {
            display: grid;
            gap: 2px;
            margin-top: 8px;
            justify-content: center;
        }

        .matrix-cell {
            width: 28px;
            height: 28px;
            border: 2px solid #555;
            background: rgba(51, 51, 51, 0.8);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.2s ease;
            position: relative;
        }

        .matrix-cell:hover {
            border-color: #4CAF50;
            transform: scale(1.05);
        }

        .matrix-cell.positive {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .matrix-cell.negative {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
        }

        .matrix-cell.neutral {
            background: rgba(51, 51, 51, 0.8);
            color: #888;
        }

        .matrix-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
        }

        .matrix-btn {
            flex: 1;
            padding: 4px 8px;
            font-size: 11px;
            background: rgba(51, 51, 51, 0.8);
            border: 1px solid #555;
            color: #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .matrix-btn:hover {
            background: rgba(76, 175, 80, 0.2);
            border-color: #4CAF50;
        }

        .copy-replace-ui {
            margin-top: 15px;
        }

        .particle-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px;
            padding: 8px;
            background: rgba(40, 40, 40, 0.6);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .particle-row:last-child {
            margin-bottom: 0;
        }

        .particle-type {
            min-width: 24px;
            font-weight: bold;
            text-align: center;
            color: white;
        }

        .particle-select {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid #555;
            background: rgba(51, 51, 51, 0.9);
            color: white;
            border-radius: 4px;
            font-size: 12px;
        }

        .particle-select:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .color-indicator {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .header-title {
            text-align: center;
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #4CAF50, #2196F3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .section-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #fff;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 4px;
        }

        @media (max-width: 768px) {
            .controls {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }
        }

        /* Scrollbar styling */
        .controls::-webkit-scrollbar {
            width: 6px;
        }

        .controls::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .controls::-webkit-scrollbar-thumb {
            background: rgba(76, 175, 80, 0.7);
            border-radius: 3px;
        }

        .controls::-webkit-scrollbar-thumb:hover {
            background: rgba(76, 175, 80, 0.9);
        }
    </style>
</head>
<body>
    <canvas id="gpu-canvas"></canvas>
    
    <div class="controls">
        <div class="header-title">Particle Affinity Simulation</div>

        <button id="restart">Restart Simulation</button>
        
        <div class="control-group">
            <label for="grid-size">Grid Size:</label>
            <input type="number" id="grid-size" value="400" min="100" max="1000" step="50">
        </div>
        
        <div class="control-group">
            <label for="num-types">Particle Types:</label>
            <input type="number" id="num-types" value="6" min="2" max="12" onchange="updateParticleTypes()">
        </div>
        
        <div class="control-group">
            <label for="density">Density:</label>
            <input type="number" id="density" value="0.15" min="0.05" max="0.9" step="0.05">
        </div>
        
        <div class="control-group">
            <label for="radius">Interaction Radius:</label>
            <input type="number" id="radius" value="3" min="1" max="10">
        </div>
        
        <div class="control-group">
            <div class="section-title">Particle Affinity Matrix</div>
            <div style="font-size: 11px; color: #aaa; margin-bottom: 8px;">
                Colors match particle types. Click cells to toggle attraction (+), neutral (0), or repulsion (âˆ’).
            </div>
            <div class="matrix-controls">
                <button class="matrix-btn" onclick="randomizeMatrix()">Random</button>
                <button class="matrix-btn" onclick="clearMatrix()">Clear</button>
                <button class="matrix-btn" onclick="identityMatrix()">Identity</button>
            </div>
            <div class="affinity-matrix">
                <div id="affinity-grid" class="matrix-grid"></div>
            </div>
        </div>

        <div class="control-group copy-replace-ui">
            <div class="section-title">Copy & Replace Rules</div>
            <div style="font-size: 11px; color: #aaa; margin-bottom: 8px;">
                Each particle type can copy one type and replace another
            </div>
            <div id="copy-replace-container"></div>
        </div>
    </div>

    <script type="module">
        import init, { ParticleGrid } from "./pkg/particle_affinity_wasm.js";

        // Particle colors matching the shader
        function getParticleColor(type) {
            if (type === 0) return [0, 0, 0];
            if (type === 1) return [255, 102, 102];
            if (type === 2) return [102, 255, 102];
            if (type === 3) return [102, 102, 255];
            if (type === 4) return [255, 255, 102];
            if (type === 5) return [255, 102, 255];
            if (type === 6) return [102, 255, 255];
            
            // HSV to RGB for higher types
            const hue = ((type - 1) % 12) / 12;
            const s = 0.8;
            const v = 1.0;
            
            const c = v * s;
            const h_prime = hue * 6;
            const x = c * (1 - Math.abs((h_prime % 2) - 1));
            const m = v - c;
            
            let r, g, b;
            if (h_prime < 1) [r, g, b] = [c, x, 0];
            else if (h_prime < 2) [r, g, b] = [x, c, 0];
            else if (h_prime < 3) [r, g, b] = [0, c, x];
            else if (h_prime < 4) [r, g, b] = [0, x, c];
            else if (h_prime < 5) [r, g, b] = [x, 0, c];
            else [r, g, b] = [c, 0, x];
            
            return [(r + m) * 255, (g + m) * 255, (b + m) * 255];
        }

        function colorToHex(rgb) {
            return `rgb(${Math.round(rgb[0])}, ${Math.round(rgb[1])}, ${Math.round(rgb[2])})`;
        }

        let affinityMatrix = [];
        let copyTypes = [];
        let replaceTypes = [];
        let currentNumTypes = 6;
        let grid = null;

        // Initialize affinity matrix with random values
        function initAffinityMatrix() {
            const numTypes = parseInt(document.getElementById("num-types").value);
            currentNumTypes = numTypes;
            affinityMatrix = Array((numTypes + 1) * (numTypes + 1));
            
            // Generate random affinity values including type 0
            for (let i = 0; i < affinityMatrix.length; i++) {
                const rand = Math.random();
                affinityMatrix[i] = rand < 0.33 ? -1 : rand < 0.66 ? 0 : 1;
            }
        }

        function initCopyReplaceArrays() {
            copyTypes = Array(currentNumTypes + 1).fill(1);
            replaceTypes = Array(currentNumTypes + 1).fill(1);
            
            // Initialize with different values for each type
            for (let i = 1; i <= currentNumTypes; i++) {
                copyTypes[i] = (i % currentNumTypes) + 1;
                replaceTypes[i] = ((i + 1) % currentNumTypes) + 1;
                // Ensure replace type is different from copy type
                if (replaceTypes[i] === copyTypes[i]) {
                    replaceTypes[i] = (replaceTypes[i] % currentNumTypes) + 1;
                }
            }
        }

        function updateParticleTypes() {
            const numTypes = parseInt(document.getElementById("num-types").value);
            if (numTypes === currentNumTypes) return;

            const oldMatrix = [...affinityMatrix];
            const oldCopy = [...copyTypes];
            const oldReplace = [...replaceTypes];
            const oldSize = currentNumTypes;
            
            currentNumTypes = numTypes;
            
            // Update affinity matrix (including type 0)
            affinityMatrix = Array((numTypes + 1) * (numTypes + 1)).fill(0);
            for (let i = 0; i <= Math.min(numTypes, oldSize); i++) {
                for (let j = 0; j <= Math.min(numTypes, oldSize); j++) {
                    const oldIdx = i * (oldSize + 1) + j;
                    const newIdx = i * (numTypes + 1) + j;
                    affinityMatrix[newIdx] = oldMatrix[oldIdx] || 0;
                }
            }
            
            // Update copy/replace arrays
            copyTypes = Array(numTypes + 1).fill(1);
            replaceTypes = Array(numTypes + 1).fill(1);
            
            for (let i = 1; i <= Math.min(numTypes, oldSize); i++) {
                copyTypes[i] = oldCopy[i] && oldCopy[i] <= numTypes ? oldCopy[i] : 1;
                replaceTypes[i] = oldReplace[i] && oldReplace[i] <= numTypes ? oldReplace[i] : 1;
            }
            
            // Initialize new types
            for (let i = oldSize + 1; i <= numTypes; i++) {
                copyTypes[i] = (i % numTypes) + 1;
                replaceTypes[i] = ((i + 1) % numTypes) + 1;
                if (replaceTypes[i] === copyTypes[i]) {
                    replaceTypes[i] = (replaceTypes[i] % numTypes) + 1;
                }
            }
            
            renderAffinityMatrix();
            renderCopyReplaceUI();
            updateSimulationRules();
        }

        function renderAffinityMatrix() {
            const gridEl = document.getElementById('affinity-grid');
            const numTypes = currentNumTypes;
            
            gridEl.style.gridTemplateColumns = `repeat(${numTypes}, 1fr)`;
            gridEl.innerHTML = '';
            
            // Only show matrix for types 1 to numTypes (skip type 0)
            for (let i = 1; i <= numTypes; i++) {
                for (let j = 1; j <= numTypes; j++) {
                    const idx = i * (numTypes + 1) + j;  // Adjust for type 0 inclusion
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    // cell.onclick = () => toggleAffinityCell(idx);
                    cell.onclick = (() => {
                        const r = i;
                        const c = j;
                        return () => toggleAffinityCell(r, c);
                    })();
                    
                    // Add color border to indicate particle type
                    const rowColor = getParticleColor(i);
                    const colColor = getParticleColor(j);
                    cell.style.borderLeft = `3px solid ${colorToHex(rowColor)}`;
                    cell.style.borderTop = `3px solid ${colorToHex(colColor)}`;
                    
                    updateAffinityCellDisplay(cell, affinityMatrix[idx]);
                    gridEl.appendChild(cell);
                }
            }
        }

        function renderCopyReplaceUI() {
            const container = document.getElementById('copy-replace-container');
            container.innerHTML = '';
            
            for (let i = 1; i <= currentNumTypes; i++) {
                const row = document.createElement('div');
                row.className = 'particle-row';
                
                const color = getParticleColor(i);
                const colorIndicator = document.createElement('div');
                colorIndicator.className = 'color-indicator';
                colorIndicator.style.backgroundColor = colorToHex(color);
                
                const typeLabel = document.createElement('div');
                typeLabel.className = 'particle-type';
                typeLabel.textContent = i;
                
                const copyLabel = document.createElement('span');
                copyLabel.textContent = 'copies';
                copyLabel.style.fontSize = '11px';
                copyLabel.style.color = '#aaa';
                
                const copySelect = document.createElement('select');
                copySelect.className = 'particle-select';
                copySelect.onchange = () => updateCopyType(i, parseInt(copySelect.value));
                
                for (let j = 1; j <= currentNumTypes; j++) {
                    if (j !== i) {
                        const option = document.createElement('option');
                        option.value = j;
                        option.textContent = `Type ${j}`;
                        if (j === copyTypes[i]) option.selected = true;
                        copySelect.appendChild(option);
                    }
                }
                
                const replaceLabel = document.createElement('span');
                replaceLabel.textContent = 'replaces';
                replaceLabel.style.fontSize = '11px';
                replaceLabel.style.color = '#aaa';
                
                const replaceSelect = document.createElement('select');
                replaceSelect.className = 'particle-select';
                replaceSelect.onchange = () => updateReplaceType(i, parseInt(replaceSelect.value));
                
                for (let j = 1; j <= currentNumTypes; j++) {
                    if (j !== i && j !== copyTypes[i]) {
                        const option = document.createElement('option');
                        option.value = j;
                        option.textContent = `Type ${j}`;
                        if (j === replaceTypes[i]) option.selected = true;
                        replaceSelect.appendChild(option);
                    }
                }
                
                row.appendChild(colorIndicator);
                row.appendChild(typeLabel);
                row.appendChild(copyLabel);
                row.appendChild(copySelect);
                row.appendChild(replaceLabel);
                row.appendChild(replaceSelect);
                
                container.appendChild(row);
            }
        }

        function updateAffinityCellDisplay(cell, value) {
            cell.textContent = value === 0 ? '0' : (value > 0 ? '+' : 'âˆ’');
            cell.className = 'matrix-cell ' + (value > 0 ? 'positive' : value < 0 ? 'negative' : 'neutral');
        }

        function toggleAffinityCell(row, col) {
            const matrixIndex = row * (currentNumTypes + 1) + col;
            console.log(`Toggling matrix[${matrixIndex}] (row ${row}, col ${col})`);
            console.log(`Current value: ${affinityMatrix[matrixIndex]}`);
            
            let current = affinityMatrix[matrixIndex];
            affinityMatrix[matrixIndex] = current === 1 ? 0 : current === 0 ? -1 : 1;
            
            console.log(`New value: ${affinityMatrix[matrixIndex]}`);
            
            // Update the visual cell by finding it in the grid
            const gridEl = document.getElementById('affinity-grid');
            const cells = gridEl.children;
            const visualIndex = (row - 1) * currentNumTypes + (col - 1);
            
            if (cells[visualIndex]) {
                updateAffinityCellDisplay(cells[visualIndex], affinityMatrix[matrixIndex]);
                console.log(`Updated cell at visual index ${visualIndex}`);
            } else {
                console.error(`Could not find cell at visual index ${visualIndex}`);
            }
            
            // Update simulation immediately
            updateSimulationRules();
        }

        function updateCopyType(particleType, copyType) {
            copyTypes[particleType] = copyType;
            renderCopyReplaceUI(); // Re-render to update replace options
            updateSimulationRules();
        }

        function updateReplaceType(particleType, replaceType) {
            replaceTypes[particleType] = replaceType;
            updateSimulationRules();
        }

        function updateSimulationRules() {
            if (grid && typeof grid.update_affinity === 'function') {
                grid.update_affinity(affinityMatrix);
                grid.update_copy_replace(copyTypes, replaceTypes);
                console.log("Updated simulation rules in real-time");
            }
        }

        window.randomizeMatrix = function() {
            for (let i = 0; i < affinityMatrix.length; i++) {
                affinityMatrix[i] = Math.random() < 0.33 ? -1 : Math.random() < 0.5 ? 0 : 1;
            }
            renderAffinityMatrix();
            updateSimulationRules();
        }

        window.clearMatrix = function() {
            affinityMatrix.fill(0);
            renderAffinityMatrix();
            updateSimulationRules();
        }

        window.identityMatrix = function() {
            affinityMatrix.fill(0);
            for (let i = 1; i <= currentNumTypes; i++) {
                const idx = i * (currentNumTypes + 1) + i;
                affinityMatrix[idx] = 1;
            }
            renderAffinityMatrix();
            updateSimulationRules();
        }

        window.updateParticleTypes = updateParticleTypes;

        async function initApp() {
            // Load wasm module
            await init();
            console.log("WASM module loaded successfully");

            // Setup canvas to fill screen
            const canvas = document.getElementById("gpu-canvas");
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Setup WebGPU
            if (!navigator.gpu) {
                console.error("WebGPU not supported");
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                console.error("No WebGPU adapter found");
                return;
            }

            const device = await adapter.requestDevice();
            const context = canvas.getContext("webgpu");

            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device,
                format,
                alphaMode: "premultiplied",
            });

            // Load shader
            const shaderCode = `
                @group(0) @binding(0)
                var gridTex: texture_2d<u32>;

                struct VSOut {
                    @builtin(position) pos: vec4f,
                    @location(0) uv: vec2f,
                };

                @vertex
                fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VSOut {
                    var positions = array<vec2f, 6>(
                        vec2f(-1.0, -1.0),
                        vec2f( 1.0, -1.0),
                        vec2f(-1.0,  1.0),
                        vec2f(-1.0,  1.0),
                        vec2f( 1.0, -1.0),
                        vec2f( 1.0,  1.0),
                    );

                    var uvs = array<vec2f, 6>(
                        vec2f(0.0, 1.0),
                        vec2f(1.0, 1.0),
                        vec2f(0.0, 0.0),
                        vec2f(0.0, 0.0),
                        vec2f(1.0, 1.0),
                        vec2f(1.0, 0.0),
                    );

                    var out: VSOut;
                    out.pos = vec4f(positions[vertex_index], 0.0, 1.0);
                    out.uv = uvs[vertex_index];
                    return out;
                }

                fn particle_color(t: u32) -> vec3f {
                    if (t == 0u) {
                        return vec3f(0.0, 0.0, 0.0);
                    } else if (t == 1u) {
                        return vec3f(1.0, 0.4, 0.4);
                    } else if (t == 2u) {
                        return vec3f(0.4, 1.0, 0.4);
                    } else if (t == 3u) {
                        return vec3f(0.4, 0.4, 1.0);
                    } else if (t == 4u) {
                        return vec3f(1.0, 1.0, 0.4);
                    } else if (t == 5u) {
                        return vec3f(1.0, 0.4, 1.0);
                    } else if (t == 6u) {
                        return vec3f(0.4, 1.0, 1.0);
                    } else {
                        let hue = f32(t % 12u) / 12.0;
                        let s = 0.8;
                        let v = 1.0;
                        
                        let c = v * s;
                        let h_prime = hue * 6.0;
                        let x = c * (1.0 - abs((h_prime % 2.0) - 1.0));
                        let m = v - c;
                        
                        if h_prime < 1.0 {
                            return vec3f(c + m, x + m, m);
                        } else if h_prime < 2.0 {
                            return vec3f(x + m, c + m, m);
                        } else if h_prime < 3.0 {
                            return vec3f(m, c + m, x + m);
                        } else if h_prime < 4.0 {
                            return vec3f(m, x + m, c + m);
                        } else if h_prime < 5.0 {
                            return vec3f(x + m, m, c + m);
                        } else {
                            return vec3f(c + m, m, x + m);
                        }
                    }
                }

                @fragment
                fn fs_main(in: VSOut) -> @location(0) vec4f {
                    let texSize = textureDimensions(gridTex);
                    let uv = in.uv * vec2f(texSize);
                    let coord = vec2<i32>(uv);

                    let t: u32 = textureLoad(gridTex, coord, 0).r;
                    let color = particle_color(t);
                    return vec4f(color, 1.0);
                }
            `;

            const module = device.createShaderModule({ code: shaderCode });

            // Create render pipeline
            const pipeline = device.createRenderPipeline({
                layout: "auto",
                vertex: { module, entryPoint: "vs_main" },
                fragment: {
                    module,
                    entryPoint: "fs_main",
                    targets: [{ format }],
                },
                primitive: { topology: "triangle-list" },
            });

            // Bind group setup
            const bindGroupLayout = pipeline.getBindGroupLayout(0);
            let bindGroup;

            function updateBindGroup() {
                bindGroup = device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [
                        { binding: 0, resource: textureView }
                    ],
                });
            }

            // GPU resources
            let texture;
            let textureView;

            // Initialize/restart simulation
            function restart() {
                const size = parseInt(document.getElementById("grid-size").value);
                const types = parseInt(document.getElementById("num-types").value);
                const density = parseFloat(document.getElementById("density").value);
                const radius = parseInt(document.getElementById("radius").value);

                console.log(`Creating grid: ${size}Ã—${size}, ${types} types, density ${density}, radius ${radius}`);

                // Use current affinity matrix if it exists
                const hasCustomAffinity = affinityMatrix.some(val => val !== 0);
                const customAffinity = hasCustomAffinity ? affinityMatrix : null;

                grid = new ParticleGrid(size, types, density, radius, customAffinity);
                
                // Apply copy/replace rules if they exist
                if (copyTypes.length > 0 && replaceTypes.length > 0) {
                    grid.update_copy_replace(copyTypes, replaceTypes);
                }
                
                console.log("Grid created:", grid.debug_info());

                // Allocate GPU texture
                texture = device.createTexture({
                    size: [size, size],
                    format: "r8uint",
                    usage:
                        GPUTextureUsage.COPY_DST |
                        GPUTextureUsage.TEXTURE_BINDING |
                        GPUTextureUsage.RENDER_ATTACHMENT,
                });

                textureView = texture.createView();
                updateBindGroup();
            }

            document.getElementById("restart").onclick = restart;

            // Initialize UI components
            initAffinityMatrix();
            initCopyReplaceArrays();
            renderAffinityMatrix();
            renderCopyReplaceUI();
            
            // Initialize simulation
            restart();

            // Render loop
            function frame() {
                if (grid) {
                    grid.step();

                    const data = grid.export_grid();

                    device.queue.writeTexture(
                        { texture },
                        data,
                        { bytesPerRow: grid.size },
                        [grid.size, grid.size]
                    );

                    const encoder = device.createCommandEncoder();
                    const pass = encoder.beginRenderPass({
                        colorAttachments: [
                            {
                                view: context.getCurrentTexture().createView(),
                                loadOp: "clear",
                                storeOp: "store",
                                clearValue: { r: 0.02, g: 0.02, b: 0.02, a: 1 },
                            },
                        ],
                    });

                    pass.setPipeline(pipeline);
                    pass.setBindGroup(0, bindGroup);
                    pass.draw(6);
                    pass.end();

                    device.queue.submit([encoder.finish()]);
                }
                
                requestAnimationFrame(frame);
            }

            console.log("Starting render loop");
            requestAnimationFrame(frame);
        }

        // Handle errors
        window.addEventListener('error', (e) => {
            console.error('Global error:', e.error);
        });

        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection:', e.reason);
        });

        initApp().catch(console.error);
    </script>
</body>
</html>