<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Particle Affinity - Rust WASM + WebGPU</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: black;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(15px);
            padding: 20px;
            border-radius: 12px;
            min-width: 280px;
            max-width: 350px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 6px;
            color: #ddd;
            font-weight: 500;
            font-size: 13px;
        }

        input[type="number"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #444;
            background: rgba(51, 51, 51, 0.8);
            color: white;
            border-radius: 6px;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
        }

        button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border: none;
            color: white;
            border-radius: 6px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .affinity-matrix {
            margin-top: 10px;
        }

        .matrix-grid {
            display: grid;
            gap: 2px;
            margin-top: 8px;
            justify-content: center;
        }

        .matrix-cell {
            width: 24px;
            height: 24px;
            border: 1px solid #555;
            background: rgba(51, 51, 51, 0.8);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            border-radius: 3px;
            transition: all 0.2s ease;
        }

        .matrix-cell:hover {
            border-color: #4CAF50;
            transform: scale(1.1);
        }

        .matrix-cell.positive {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .matrix-cell.negative {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
        }

        .matrix-cell.neutral {
            background: rgba(51, 51, 51, 0.8);
            color: #888;
        }

        .matrix-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
        }

        .matrix-btn {
            flex: 1;
            padding: 4px 8px;
            font-size: 11px;
            background: rgba(51, 51, 51, 0.8);
            border: 1px solid #555;
            color: #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .matrix-btn:hover {
            background: rgba(76, 175, 80, 0.2);
            border-color: #4CAF50;
        }

        .header-title {
            text-align: center;
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #4CAF50, #2196F3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        @media (max-width: 768px) {
            .controls {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }
        }
    </style>
</head>
<body>
    <canvas id="gpu-canvas"></canvas>
    
    <div class="controls">
        <div class="header-title">Particle Affinity Simulation</div>

        <button id="restart">restart</button>
        
        <div class="control-group">
            <label for="grid-size">Grid Size:</label>
            <input type="number" id="grid-size" value="400" min="100" max="1000" step="50">
        </div>
        
        <div class="control-group">
            <label for="num-types">Particle Types:</label>
            <input type="number" id="num-types" value="6" min="2" max="12" onchange="updateAffinityMatrix()">
        </div>
        
        <div class="control-group">
            <label for="density">Density:</label>
            <input type="number" id="density" value="0.15" min="0.05" max="0.9" step="0.05">
        </div>
        
        <div class="control-group">
            <label for="radius">Interaction Radius:</label>
            <input type="number" id="radius" value="3" min="1" max="10">
        </div>
        
        <div class="control-group">
            <label>Affinity Matrix:</label>
            <div class="matrix-controls">
                <button class="matrix-btn" onclick="randomizeMatrix()">Random</button>
                <button class="matrix-btn" onclick="clearMatrix()">Clear</button>
                <button class="matrix-btn" onclick="identityMatrix()">Identity</button>
            </div>
            <div class="affinity-matrix">
                <div id="affinity-grid" class="matrix-grid"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import init, { ParticleGrid } from "./pkg/particle_affinity_wasm.js";

        let affinityMatrix = [];
        let currentNumTypes = 6;

        // Initialize affinity matrix with random values
        function initAffinityMatrix() {
            const numTypes = parseInt(document.getElementById("num-types").value);
            currentNumTypes = numTypes;
            affinityMatrix = Array(numTypes * numTypes);
            
            // Generate random affinity values
            for (let i = 0; i < affinityMatrix.length; i++) {
                const rand = Math.random();
                affinityMatrix[i] = rand < 0.33 ? -1 : rand < 0.66 ? 0 : 1;
            }
        }

        function updateAffinityMatrix() {
            const numTypes = parseInt(document.getElementById("num-types").value);
            if (numTypes === currentNumTypes) return;

            const oldMatrix = [...affinityMatrix];
            const oldSize = currentNumTypes;
            
            currentNumTypes = numTypes;
            affinityMatrix = Array(numTypes * numTypes).fill(0);
            
            // Copy over existing values where possible
            for (let i = 0; i < Math.min(numTypes, oldSize); i++) {
                for (let j = 0; j < Math.min(numTypes, oldSize); j++) {
                    affinityMatrix[i * numTypes + j] = oldMatrix[i * oldSize + j];
                }
            }
            
            // Set diagonal to 1 for new types
            for (let i = oldSize; i < numTypes; i++) {
                affinityMatrix[i * numTypes + i] = 1;
            }
            
            renderAffinityMatrix();
        }

        function renderAffinityMatrix() {
            const grid = document.getElementById('affinity-grid');
            const numTypes = currentNumTypes;
            
            grid.style.gridTemplateColumns = `repeat(${numTypes}, 1fr)`;
            grid.innerHTML = '';
            
            for (let i = 0; i < numTypes * numTypes; i++) {
                const cell = document.createElement('div');
                cell.className = 'matrix-cell';
                cell.onclick = () => toggleCell(i);
                updateCellDisplay(cell, affinityMatrix[i]);
                grid.appendChild(cell);
            }
        }

        function updateCellDisplay(cell, value) {
            cell.textContent = value === 0 ? '0' : (value > 0 ? '+' : '−');
            cell.className = 'matrix-cell ' + (value > 0 ? 'positive' : value < 0 ? 'negative' : 'neutral');
        }

        function toggleCell(index) {
            let current = affinityMatrix[index];
            affinityMatrix[index] = current === 1 ? 0 : current === 0 ? -1 : 1;
            
            const cell = document.getElementById('affinity-grid').children[index];
            updateCellDisplay(cell, affinityMatrix[index]);
        }

        window.randomizeMatrix = function() {
            for (let i = 0; i < affinityMatrix.length; i++) {
                affinityMatrix[i] = Math.random() < 0.33 ? -1 : Math.random() < 0.5 ? 0 : 1;
            }
            renderAffinityMatrix();
        }

        window.clearMatrix = function() {
            affinityMatrix.fill(0);
            renderAffinityMatrix();
        }

        window.identityMatrix = function() {
            affinityMatrix.fill(0);
            for (let i = 0; i < currentNumTypes; i++) {
                affinityMatrix[i * currentNumTypes + i] = 1;
            }
            renderAffinityMatrix();
        }

        window.updateAffinityMatrix = updateAffinityMatrix;

        async function initApp() {
            // Load wasm module
            await init();
            console.log("WASM module loaded successfully");

            // Setup canvas to fill screen
            const canvas = document.getElementById("gpu-canvas");
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Setup WebGPU
            if (!navigator.gpu) {
                console.error("WebGPU not supported");
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                console.error("No WebGPU adapter found");
                return;
            }

            const device = await adapter.requestDevice();
            const context = canvas.getContext("webgpu");

            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device,
                format,
                alphaMode: "premultiplied",
            });

            // Load shader
            const shaderCode = `
                @group(0) @binding(0)
                var gridTex: texture_2d<u32>;

                struct VSOut {
                    @builtin(position) pos: vec4f,
                    @location(0) uv: vec2f,
                };

                @vertex
                fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VSOut {
                    var positions = array<vec2f, 6>(
                        vec2f(-1.0, -1.0),
                        vec2f( 1.0, -1.0),
                        vec2f(-1.0,  1.0),
                        vec2f(-1.0,  1.0),
                        vec2f( 1.0, -1.0),
                        vec2f( 1.0,  1.0),
                    );

                    var uvs = array<vec2f, 6>(
                        vec2f(0.0, 1.0),
                        vec2f(1.0, 1.0),
                        vec2f(0.0, 0.0),
                        vec2f(0.0, 0.0),
                        vec2f(1.0, 1.0),
                        vec2f(1.0, 0.0),
                    );

                    var out: VSOut;
                    out.pos = vec4f(positions[vertex_index], 0.0, 1.0);
                    out.uv = uvs[vertex_index];
                    return out;
                }

                fn particle_color(t: u32) -> vec3f {
                    if (t == 0u) {
                        return vec3f(0.0, 0.0, 0.0);
                    } else if (t == 1u) {
                        return vec3f(1.0, 0.4, 0.4);
                    } else if (t == 2u) {
                        return vec3f(0.4, 1.0, 0.4);
                    } else if (t == 3u) {
                        return vec3f(0.4, 0.4, 1.0);
                    } else if (t == 4u) {
                        return vec3f(1.0, 1.0, 0.4);
                    } else if (t == 5u) {
                        return vec3f(1.0, 0.4, 1.0);
                    } else if (t == 6u) {
                        return vec3f(0.4, 1.0, 1.0);
                    } else {
                        let hue = f32(t % 12u) / 12.0;
                        let s = 0.8;
                        let v = 1.0;
                        
                        let c = v * s;
                        let h_prime = hue * 6.0;
                        let x = c * (1.0 - abs((h_prime % 2.0) - 1.0));
                        let m = v - c;
                        
                        if h_prime < 1.0 {
                            return vec3f(c + m, x + m, m);
                        } else if h_prime < 2.0 {
                            return vec3f(x + m, c + m, m);
                        } else if h_prime < 3.0 {
                            return vec3f(m, c + m, x + m);
                        } else if h_prime < 4.0 {
                            return vec3f(m, x + m, c + m);
                        } else if h_prime < 5.0 {
                            return vec3f(x + m, m, c + m);
                        } else {
                            return vec3f(c + m, m, x + m);
                        }
                    }
                }

                @fragment
                fn fs_main(in: VSOut) -> @location(0) vec4f {
                    let texSize = textureDimensions(gridTex);
                    let uv = in.uv * vec2f(texSize);
                    let coord = vec2<i32>(uv);

                    let t: u32 = textureLoad(gridTex, coord, 0).r;
                    let color = particle_color(t);
                    return vec4f(color, 1.0);
                }
            `;

            const module = device.createShaderModule({ code: shaderCode });

            // Create render pipeline
            const pipeline = device.createRenderPipeline({
                layout: "auto",
                vertex: { module, entryPoint: "vs_main" },
                fragment: {
                    module,
                    entryPoint: "fs_main",
                    targets: [{ format }],
                },
                primitive: { topology: "triangle-list" },
            });

            // Bind group setup
            const bindGroupLayout = pipeline.getBindGroupLayout(0);
            let bindGroup;

            function updateBindGroup() {
                bindGroup = device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [
                        { binding: 0, resource: textureView }
                    ],
                });
            }

            // GPU resources
            let grid;
            let texture;
            let textureView;

            // Initialize/restart simulation
            function restart() {
                const size = parseInt(document.getElementById("grid-size").value);
                const types = parseInt(document.getElementById("num-types").value);
                const density = parseFloat(document.getElementById("density").value);
                const radius = parseInt(document.getElementById("radius").value);

                console.log(`Creating grid: ${size}×${size}, ${types} types, density ${density}, radius ${radius}`);

                // Use current affinity matrix or null for random
                const hasCustomAffinity = affinityMatrix.some(val => val !== 0);
                const customAffinity = hasCustomAffinity ? affinityMatrix : null;

                grid = new ParticleGrid(size, types, density, radius, customAffinity);
                console.log("Grid created:", grid.debug_info());

                // Allocate GPU texture
                texture = device.createTexture({
                    size: [size, size],
                    format: "r8uint",
                    usage:
                        GPUTextureUsage.COPY_DST |
                        GPUTextureUsage.TEXTURE_BINDING |
                        GPUTextureUsage.RENDER_ATTACHMENT,
                });

                textureView = texture.createView();
                updateBindGroup();
            }

            document.getElementById("restart").onclick = restart;

            // Initialize affinity matrix and render it
            initAffinityMatrix();
            renderAffinityMatrix();
            
            // Initialize simulation
            restart();

            // Render loop
            function frame() {
                grid.step();

                const data = grid.export_grid();

                device.queue.writeTexture(
                    { texture },
                    data,
                    { bytesPerRow: grid.size },
                    [grid.size, grid.size]
                );

                const encoder = device.createCommandEncoder();
                const pass = encoder.beginRenderPass({
                    colorAttachments: [
                        {
                            view: context.getCurrentTexture().createView(),
                            loadOp: "clear",
                            storeOp: "store",
                            clearValue: { r: 0.02, g: 0.02, b: 0.02, a: 1 },
                        },
                    ],
                });

                pass.setPipeline(pipeline);
                pass.setBindGroup(0, bindGroup);
                pass.draw(6);
                pass.end();

                device.queue.submit([encoder.finish()]);
                requestAnimationFrame(frame);
            }

            console.log("Starting render loop");
            requestAnimationFrame(frame);
        }

        // Handle errors
        window.addEventListener('error', (e) => {
            console.error('Global error:', e.error);
        });

        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection:', e.reason);
        });

        initApp().catch(console.error);
    </script>
</body>
</html>